

## AKKA文档

http://jasonqu.github.io/akka-doc-cn/2.3.6/scala/book/index.html

### 什么是AKKA？
```
可扩展的实时事务处理

我们相信编写并发、容错、可扩展的应用相当的困难。盖因大多数时候我们一直在使用错误的工具和错误的抽象等级。
AKKA就是为了改变这一切的。我们利用角色模型提升了抽象等级，并且提供了一个用来构建可扩展的、弹性的以及响应式应用的更好的平台
——更多信息请见Reactive Manifesto。对于容错机制我们采用“让它崩溃”模型，这一模型已在电信行业取得了巨大的成功，
旨在构建自我修复与永不停机的系统。角色还提供了透明的分布式抽象以及真正的可扩展且容错应用的基础。

AKKA是开源的，并遵守Apache2许可。
```


```
AKKA实现了一个独特的混合

角色
角色给你提供了：
并发与并行性的高等级抽象
异步、无锁以及高性能的事件驱动编程模型
非常轻量级的事件驱动流程（1GB堆内存可容纳几百万的角色）

容错
拥有“让它崩溃”语义的管理层级
管理层级可跨越多个JVM，实现真正的容错系统
非常适合编写可自我修复且永不停机的高容错能力的系统

位置透明
AKKA的一切旨在分布式环境中工作：角色之间都使用纯消息交互，而且一切都是异步的。

持久化
启动或重启角色时，可以选择持久化或重放它接收到的消息。
在JVM崩溃或角色迁移到另一节点时，这一点可以使角色恢复它的状态。

Scala和Java API
AKKA拥有Scala和Java两种语言的接口文档。

AKKA有两种使用方式
作为一个库：将它放到WEB-INF/lib下面供一个web应用使用，或把它当作一个常规的JAR放到你的类路径里。
微内核方式：将你的应用放到独立的内核里。

```

### 为什么选择Akka

```
与同类其它产品相比，Akka平台有什么过人之处呢？

Akka 提供可伸缩的实时事务处理能力。

Akka在以下方面提供了一致的运行时和编程模型：
纵向扩展性（并发）
横向扩展性（远程调用）
容错性

由于Akka的高内聚性和连贯的语义，学习和管理就成了一件事。

Akka是一款极具可伸缩性的软件，它的可伸缩性不仅体现在性能方面，在控制应用程序的大小方面也很实用。
Akka的内核—akka-actor, 非常小并且很容易植入已有项目中。
当你的项目需要异步或没有冲突的无锁并发时就可以考虑将akka-actor植入你的程序。

你还可以对akka核进行瘦身，使其只包含你的程序用到的部分，我们称这个瘦身后的包为Akka微内核。
然后基于它来部署你的Akka应用。随着cpu核心数的持续攀升，为了得到系统性能方面的提升akka也成了一个不错的选择。
因为Akka即使在单机环境下也能提供杰出的性能。Akka还提供了一系列的并发范式，用户可以根据自己的需求特点选择最优的方案。

Akka适用于那些场景？

Akka被很多大型组织在不同的领域所采用，如：
· 投资和商业银行业务
· 零售业
· 社交媒体
· 仿真
· 游戏和赌博
· 汽车和交通系统
· 医疗卫生
· 数据分析
等等。任何系统只要是需要高吞吐量或低延迟率的都可以考虑使用Akka。

通过角色(Actor)来管理服务故障(Supervisor)，负载管理(回退策略，超时以及进程隔离)，以及水平和垂直的伸缩性管理(增加cpu核或增加机器数量)。

下面的链接是Akka的使用者对他们是怎样使用Akka的一些评论：
http://stackoverflow.com/questions/4493001/good-use-case-for-akka
所有这些都是基于ApacheV2的开源项目。
```



### 准备开始

```
入门指南与模板项目
学习AKKA的最好方式是下载Typesafe Activator[ http://www.lightbend.com/activator/download ]并尝试一个AKKA模板项目。

下载
有许多种下载AKKA的方式。你可以把它当作Typesafe平台的一部分下载（就像上面描述的）。
还可以下载完全发布版，它包含微内核以及所有模块。或者使用像Maven或SBT这样的构建工具从AKKA Maven仓库下载依赖。

模块
AKKA是调度模块化的，它由许多拥有不同特性的JAR组成。

akka-actor – 经典角色、类型角色、IO角色等。
akka-agent – 代理、整合了Scala的STM特性
akka-camel – 整合Apache的Camel
akka-cluster – 集群成员管理、弹性路由
akka-kernel – AKKA微内核，运行着一个极简应用服务器
akka-osgi – 在OSGI容器里使用AKKA的基本bundle，包括akka-actor的类
akka-osgi-aries – Aries——服务提供角色系统的蓝图
akka-remote – 远程角色
akka-slf4j – SLF4J Logger (事件总线监听器)
akka-testkit – 测试角色系统的工具包Toolkit for testing Actor systems
akka-zeromq – 整合ZeroMQ

除了这些已进入稳定内核的稳定模块之外，还有许多标记为“试验（experimental）”的模块。
这并不是意味着它们没有达到预期的功能，它的主要意义是这些模块的API尚不够稳定。
你可以通过邮件列表向我们反馈这些模块的使用情况，帮助加快这一进程。

akka-contrib – 提交者贡献的各种模块可能会也可能不被移到核心模块，见外部贡献了解更多细节。

一个实际的JAR文件名如下所示：akka-actor_2.10-2.3.6.jar（其它模块也是如此）。
在依赖关系章节说明了各AKKA模块的JAR之间的依赖关系。

使用发布版
从 http://akka.io/downloads下载你需要的发布版并解压缩。

使用快照版
每日构建的AKKA快照版发布在http://repo.akka.io/snapshots/，并同时以SNAPSHOT和时间戳标记版本。
你可以选择使用一个时间戳标记的版本并决定何时升级到一个更新版本。
AKKA快照仓库还通过http://repo.typesafe.com/typesafe/snapshots/代理了AKKA模块依赖的许多其它仓库的代理。

警告
除非你知道你在做什么，否则不鼓励使用AKKA的快照版、每日构建版和里程碑版。

微内核
AKKA的发布版拥有一个微内核。将你的应用JAR放到deploy目录并运行bin 目录下的脚本。

使用构建工具
AKKA可以使用支持Maven仓库的构建工具

Maven仓库

从AKKA2.1-M2版开始：
Maven中央仓库（http://repo1.maven.org/maven2/）
之前的版本：
AKKA仓库（http://repo.akka.io/releases/） Typesafe仓库（http://dl.bintray.com/typesafe/maven-releases/）

通过Maven使用AKKA

开始使用AKKA和Maven的最简单的方式是检出Typesafe Activator名为
Akka Main in Java（http://www.lightbend.com/activator/template/akka-sample-main-java）的教程。

既然AKKA发布到了Maven中央仓库（从v2.1-M2开始），当然可以通过POM添加AKKA依赖。
比如下面就是akka-actor模块的依赖

模块的依赖
<dependency>
    <groupId>com.typesafe.akka</groupId>
    <artifactId>akka-actor_2.10</artifactId>
    <version>2.3.6</version>
</dependency>
注意：对于快照版，SNAPSHOT 与时间戳版本同时发布。


通过SBT使用AKKA

最简单的方法是检出Akka/SBT template工程。

SBT中的AKKA的必要部分：
SBT安装指南：https://github.com/harrah/xsbt/wiki/Setup

build.sbt文件：
name:="My Project"
version:="1.0"
scalaVersion:="2.10.4"
resolvers+="Typesafe Repository" at "http://typesafe.com/typesafe/releases/"
libraryDependencies+="com.typesafe.akka" %% "akka-actor" % "2.3.6"

注意：在上面的libraryDependencies设置中，指定SBT版本为v0.12.x或更高版本。
如果你使用较早的SBT版本，libraryDependencies应像下面这样：
libraryDependencies+="com.typesafe.akka" %% "akka-actor_2.10" % "2.3.6"


在IntelliJ IDEA中使用AKKA
安装SBT工程然后使用 sbt-idea生成IntelliJ IDEA工程。

从源码构建
Akka使用Git托管在Github上。
从http://github.com/akka/akka克隆Akka仓库

需要帮助？
如果你有问题可以从Akka邮件列表（https://groups.google.com/forum/#!forum/akka-user）获得帮助。
你也可以获取商业支持。


```

### hello world

```
将著名的问候语——“Hello World”——打印在控制台中，这个艰巨任务的actor版在
Typesafe Activator中一个名为
Akka Main in Java项目中已有介绍。

本教程说明了通用启动器类akka.Main，只接收一个命令行参数：应用的主actor类名。
这个main方法将为运行actor创建基础设施，用来启动指定的主actor以及在主actor终止时为关闭整个应用做出安排。
akkadocument.sample.hello.Main

Typesafe Activator中有相同问题域的另一个名为Hello Akka!的教程讲述了更深入的akka基础知识。
```

### 用例与部署场景

```
我如何使用与部署akka？

有两种不同的使用akka的方式：
作为一个库：作为一个web应用的类路径下的普通JAR使用，将它放在WEB-INF/lib。
在一上主类中通过实例化ActorSystem作为一个独立的应用运行，或使用微内核 (Scala) /(Java)。

将akka作为一个库使用
如果你在构建一个web应用，这可能就是你想要的。在库模式下，通过向模块栈添加越来越多的模块有许多种使用akka的方式。
将akka作为独立的微内核使用

akka还可以作为一个独立的微内核运行。更多信息见微内核 (Scala) / (Java) 。
http://doc.akka.io/docs/akka/2.3.6/scala/microkernel.html#microkernel-scala
http://doc.akka.io/docs/akka/2.3.6/java/microkernel.html#microkernel-java
```


### akka的用例示例
```
我们看到akka正被许多大型组织所采用，已被广泛应用于投资与商业银行业务，零食与社交媒体，虚拟仿真，游戏与博彩，数据分析等等行业。
任何需要高吞吐量和低延迟的系统都是使用akka的良好候选者。

这里(http://stackoverflow.com/questions/4493001/good-use-case-for-akka/4494512#4494512)
有一些良好的关于akka用例的讨论以及在生产环境的使用评论。

下面是一些已将akka部署到生产环境的领域

事务处理（在线游戏，金融、银行，贸易，统计，博彩，社会化媒体，电信）
纵向扩展，横向扩展，容错/HA

后端服务 (任何行业，任何应用)
REST服务, SOAP, Cometd, WebSockets等，充当信息枢纽/集成层纵向扩展 、横向扩展，容错/HA

并发/并行性（任何应用）
简单正确的使用与理解akka仅仅是将它的jar添加到你的JVM工程（使用Scala、Java、Groovy或JRuby）

虚拟仿真
主/从，计算风格，MapReduce等

批处理（任何行业）
Camel与批量数据源整合，角色对工作负载分而治之

通讯枢纽（电信、网络媒体、移动媒体）
纵向扩展，横向扩展，容错/HA

游戏与博彩（MOM（消息中间件），网络游戏，博彩）
纵向扩展，横向扩展，容错/HA

商业智能/数据挖掘/通用运算
纵向扩展，横向扩展，容错/HA

复杂的事件流处理
纵向扩展，横向扩展，容错/HA
```

## 综述
```
这一章我们将尝试建立通用的术语，对Akka面向的并发、分布式系统等提供一个坚实的讨论基础。
请注意，这里的很多术语都没有统一的定义。我们只是希望在Akka文档的范围内给出可用的定义。
```


### 术语，概念
```
并发 vs. 并行

并发和并行是相关的定义，有一些微小的不同。
并发 指的是两个或多个任务都有进展，即使他们没有被同时执行。例如可以这样实现：划分出时间片，几个任务交叉执行，尽管时间片的执行是线性的。
并行 则是指可以真正同时执行。

异步 vs. 同步

一个方法调用是 同步 的，当调用者不能继续处理，除非方法返回一个值或抛出一个异常。
另一方面，一个 异步 调用允许调用者在调用方法的有限步后能够继续执行，并且该方法的结束可以被额外的机制通知到
（也许是一个注册的回调callback，一个Future或一个消息）。

一个同步的API也许会使用阻塞实现同步性，但也不是必须的。
一个CPU极为密集的任务也会导致类似阻塞的行为。通常推荐使用非阻塞API，因为它们能确保系统继续处理。
Actor本质上是异步的：一个Actor可以在发送消息后继续处理，而不需要等待消息确实被送达。


非阻塞 vs. 阻塞

如果一个线程的延迟会导致其它一些线程无限期的延迟，我们称之为 阻塞。
一个很好的例子是资源可以被线程通过互斥锁独占。如果这个线程无限期地占有这个资源（例如不小心进入死循环），
其他等待这个资源的线程就无法处理了。相反地，非阻塞 意味着没有线程可以无限期的阻塞其他线程。

相比阻塞操作，我们推荐非阻塞的操作，因为很明显这样系统不会因为阻塞操作而不再继续处理。

死锁 vs. 饥饿 vs. 活锁

当多个参与者互相等待别人达到某个特殊的状态才能继续处理的时候，死锁 出现了。
因为如果一些参与者不达到特定状态，所有的参与者都不能执行（就像《第二十二条军规》描述的那样），
所有相关子系统都停顿了。死锁和阻塞息息相关，因为阻塞使得一个参与者线程可以无限期地推迟其他线程的处理。

在死锁中，没有参与者可以处理，然而相对的 饥饿 可能发生，当有些参与者可以不断地处理，而另一些可能不行。
一个典型的场景是一个幼稚的调度算法——总是选择高优先级的任务。如果高优先级的任务数量一直足够多，则低优先级的任务永远不会被完成。

活锁 和死锁类似，没有参与者可以处理。区别在于与进程进入等待其他进程处理的“冻结”状态不同，
参与者不断地变换他们的状态。一个示例场景是两个参与者和两个特殊的资源。
他们分别试图获取资源，并且检查是不是另一个参与者也需要这个资源。如果该资源被另一个参与者请求，
则它们试图获取另一个资源。在一个很不幸的情况下，也许两个参与者会不停的在两个资源上“跳跃”，永远在谦让而不使用资源。

竞态条件

当一组事件的顺序假设可能被外部不确定因素影响，我们称之为 竞态条件。
竞态条件经常在多个线程共享一个可变状态时出现，一个线程对这个状态的操作可能被交织从而导致意外的行为。
尽管这是常见的情况，但是共享状态并不一定会导致竞态条件。例如一个客户端向服务器发送无序的包（例如UDP数据包）P1，P2。
由于包可能经过不同的网络路由器传送，所以服务器可能先收到P2，后收到P1。
如果消息中没有包含发送顺序的相关信息的话，服务器是不可能确定包是否是按照发送顺序接收的。根据包的内容这可能会导致竞态条件。

注意
对两个actor之间的消息发送，Akka唯一提供的保证是消息的发送顺序是被保留的。详见 消息传送可靠性Message Delivery Reliability

非阻塞担保（进展条件）
就像前几个章节描述的，阻塞是不受欢迎的，因为它有可能导致死锁并降低系统的吞吐量。在下面几节，我们将从不同深度讨论各种无阻塞特性。

无等待（Wait-freedom）
如果一个方法的调用可以保证在有限步骤内完成，则称该方法是 无等待 的。如果方法是 有界无等待 的，则方法的执行步数有一个确定的上界。

从这个定义可以得出无等待的方法永远不会阻塞，因此死锁是不可能发生的。
此外，因为每个参与者都可以经过有限步后继续执行（当调用完成），所以无等待方法也不会出现饥饿的情况。

无锁（Lock-freedom）

无锁 是比 无等待 更弱的特性。在无锁调用的情况下，无限地经常有一些方法在有限步骤内完成。这个定义暗示着对无锁调用是不可能出现死锁的。
另一方面，部分方法调用 在有限步骤内 结束，不足以保证所有调用最终完成。换句话说，无锁不足以保证不会出现饥饿。

无阻碍（Obstruction-freedom）
无阻碍 是这里讨论的最弱的无阻塞保证。对一个方法，当在某一个它独自执行的时间点（其他线程不在执行，例如都挂起了），
之后它在有限步后能够结束，我们称之为 无阻碍。所有无锁的对象都是无阻碍的，但反之一般不成立。

乐观并发模型OCC（Optimistic concurrency control ） 的方法通常是无阻碍的。
OCC的做法是，每一位参与者都试图在共享对象上执行操作，但是如果参与者检测到来自其他参与者的冲突，它回滚修改，并根据调度再次尝试。
如果在某一个时间点，其中一个参与者，是唯一一个尝试修改的点，则其操作就会成功。

推荐文献
The Art of Multiprocessor Programming, M. Herlihy and N Shavit, 2008. ISBN 978-0123705914 （注：中文译《多处理器编程的艺术》）

Java Concurrency in Practice, B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes and D. Lea, 2006. ISBN 978-0321349606（注：中文译《Java并发编程实战》）

```

### Actor系统
```
Actor是封装状态和行为的对象，他们唯一的通讯方式是交换消息——把消息存放在接收方的邮箱里。
从某种意义上来说，actor是面向对象最严格的形式，不过最好把它们比作人：在使用actor来对解决方案建模时，把actor想象成一群人，
把子任务分配给他们，将他们的功能整理成一个有组织的结构，考虑如何将失败逐级上传（好在我们并不需要真正跟人打交道，
这样我们就不需要关心他们的情绪状态和道德问题）。这个结果就可以作为软件实现的思维框架。

注意:
一个Actor系统是一个很重的结构，它会分配一到N个线程，所以对每一个逻辑应用创建一个就够了。

树形结构
象一个经济组织一样，actor自然形成树形结构。程序中负责某一功能的actor，可能需要把它的任务分拆成更小的、更易管理的部分。
为此它启动子actor并监督它们。虽然后面章节会解释监督机制的细节，我们会集中在这一节里介绍其中的根本思想，
唯一需要了解的前提是每个actor有且仅有一个监管者，就是创建它的那个actor。

Actor系统的精髓在于任务被拆开、委托，直到任务小到可以被完整地处理。
这样做不仅清晰地划分出了任务本身的结构，而且最终的actor也能按照它们“应该处理什么类型的消息”，
“如何处理正常流程”以及“如何应对失败流程”来进行推理。如果一个actor对某种状况无法进行处理，
它会发送相应的失败消息给它的监管者请求帮助。这样的递归结构使得失败能够在正确的层次得到处理。

可以将这种思想与分层的设计方法进行比较。分层的设计方法最终很容易形成防护性编程，以防止任何失败被泄露出来；
相比之下把问题交由正确的人处理会是比将所有的事情“藏在深处”更好的解决方案。

现在，设计这种系统的难度在于如何决定谁应该监管什么。这当然没有唯一的最佳方案，但是有一些指导原则可能会有帮助：

如果一个actor管理另一个actor所做的工作，如分配一个子任务，那么父actor应该监督子actor。因为父actor知道可能会出现哪些失败情况，以及如何处理它们。
如果一个actor携带着重要数据（即它的状态要尽可能地不被丢失），这个actor应该将任何可能出现危险的子任务分配给它所监管的子actor，并酌情处理子任务的失败。根据请求的性质，可能的话最好为每一个请求创建一个子actor，这样能简化收集回应的状态管理。这在Erlang中被称为“Error Kernel Pattern”。
如果actor A需要依赖actor B才能完成它的任务，A应该观测B的存活状态并对B的终止提醒消息进行响应。这与监管机制不同，因为观测方对监管机制没有影响；需要指出的是，仅仅是功能上的依赖并不足以用来决定是否在树形监管体系中添加子actor.

当然以上的规则都会有例外，但无论是遵循这些规则还是打破它们，都需要有足够的理由。


配置容器
actor系统是多个协作actor的组，它天生就是管理调度服务、配置、日志等共享设施的单元。
使用不同配置的多个actor系统可以在同一个jvm中共存，Akka自身没有全局共享的状态。
将这与actor系统之间的透明通讯（在同一节点上或者跨网络连接的多个节点）结合，可以看到actor系统本身可以被作为功能层次中的构建单元。


Actor最佳实践
Actor应该被视为友好的同事：高效完成其工作，不会无必要地打扰其它人，也不会争抢资源。
对应在编程中，其意思是以事件驱动的方式来处理事件并生成响应（或更多的请求）。
Actor不应该因为某一个外部实体而阻塞（即占据一个线程又被动等待），这个外部实体可能是一个锁、一个网络socket等等；
除非它是不可避免的，如下一节所述。
不要在actor之间传递可变对象。为了保证这一点，选择不可变消息。如果actor将他们的可变状态暴露给外界，打破了封装，
你就回到了普通的Java并发领域并遭遇其所有缺点。
Actor是行为和状态的容器，拥抱这一点意味着不要在消息中传递行为（例如在消息中使用scala闭包）。
有一个风险是意外地在actor之间共享了可变状态，这种对actor模型规则的违反将破坏使用actor编程带来的所有良好体验。
顶级actor在错误内核最深处，所以尽量少创建它们并且选择真正的树形分层系统。这对故障处理有好处（同时考虑到配置的粒度和性能），同
时也减少了对监管actor这个竞争单点的过度使用。

阻塞需要仔细的管理
在某些情况下，阻塞操作是不可避免的，即必须不定期地休眠一个线程，等待外部事件唤醒。
例如传统的关系型数据库的驱动程序或消息传递API，而深层的原因通常是出现幕后的（网络）I/O。
面对这一点，你可能受到诱惑，只是将阻塞调用包装在 Future 中来替之工作，但这个策略太简单了：
当应用的负载增加，你很可能会发现性能瓶颈，或者出现内存或线程耗尽的情况。

对“阻塞问题”的充分解决方案的清单是不会穷尽的，但肯定会有下面的建议：

    在一个actor（或由一个路由器[Java, Scala]管理的一组actor内）内进行阻塞调用，并确保配置一个线程池，它要足够大或者专门用于这一目的。
    在一个 Future 内进行阻塞调用，确保任意时间点内这种调用的数量都在一个上限内（无限制提交这类任务会耗尽你的内存或线程）。
    在一个 Future 内进行阻塞调用，使用一个线程池，该线程池的线程数上限对应用程序运行的硬件是合适的。
    奉献一个单独的线程来管理一组阻塞资源（如一个NIO选择器驱动多个频道），并在事件发生时把它们作为actor消息发送。

第一个建议对本质上是单线程的资源特别适合，如传统数据库句柄一次只能执行一个未完成的查询，并使用内部同步保证这一点。
一个常见的模式是对N个actor创建一个router，每个actor包装一个数据库连接，并处理发送给这个router的查询。
数目N必须被调整为最大吞吐量，这个数字取决于什么数据库管理系统部署在什么硬件上。

注意:
配置线程池的任务最好代理给Akka来做，只要在application.conf中配置，并由ActorSystem [Java, Scala] 实例化即可。

你不应该担心的事
一个actor系统管理它所配置使用的资源，运行它所包含的actor。 在一个系统中可能有上百万个actor，
不用担心，内存一定是够用的，因为每个actor实例仅占差不多300个字节。自然地，一个大系统中消息处理的具体顺序是不受应用开发者控制的，
但这并不是有意为之。放松些，让Akka去做幕后的繁重事务吧。
```