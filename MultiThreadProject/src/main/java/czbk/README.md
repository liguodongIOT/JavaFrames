### 传统创建线程的两种方式
```
继承Thread类+重写run()方法
实现Runnable接口+重写run方法
```


### 传统的定时器
```
继承TimerTask类+重写run方法
```

### 传统的线程同步
```
多个线程对同一个对象进行修改
```

### 传统的线程同步
```
两个线程执行的代码片段要实现同步互斥的效果，他们必须用同一个对象。
```

### 线程范围类的数据共享（Map）
```
将数据存入Map中，线程名作为key值
```

### 线程范围类的数据共享(ThreadLocal)--底层实现是Map
```
一个变量
多个变量封装成一个实例
多个变量封装成一个实例（单例模式实现）
```

### 多个线程之间共享数据
```
Note:
一、每个线程执行的代码相同
如果每个线程执行的代码相同，可以使用同一个Runnable对象，
此Runnable对象存在共享数据,
如: 卖票程序可以这么做，因为都是执行减少的过程


二、每个线程执行的代码不相同
方法1：将需要共享的数据封装成一个对象，将该对象传给执行不同代码的Runnable对象。
方法2：将这些执行不同代码的Runnable对象作为内部类。
如：有4个线程，其中有2个线程对每次对j+1，有2个线程对每次对j-1。
加减操作无顺序。
```

### 9.原子性操作类
```
java.util.concurrent.atomic包--对类中的基本数据进行操作
AtomicBoolean、AtomicInteger、AtomicIntegerArray、
AtomicLong、...
```

### 9.线程池
```
创建固定大小的线程池
创建缓存线程池
创建单一线程池

关闭线程
shutdown和shutdownNow

定时器
```

### 10.Callable和Future

### 11.Java5的线程锁
```
多个线程要执行的代码片段要实现同步互斥，他们必须用同一个Lock对象。
锁是上在代表要操作的资源的内部方法中，而不是线程代码中。
```

### 12.Java5的读写锁
```
读写锁：分为读锁和写锁，多个读锁不互斥，读锁和写锁互斥，写锁和写锁互斥，
这是由Jvm控制的，只需上好相应的锁即可。读的时候上读锁，写的时候上写锁。
```

