### 1.传统创建线程的两种方式
```
继承Thread类+重写run()方法
实现Runnable接口+重写run方法
```


### 2.传统的定时器
```
继承TimerTask类+重写run方法
```

### 3.传统的线程同步
```
多个线程对同一个对象进行修改
```

### 4.传统的线程同步
```
两个线程执行的代码片段要实现同步互斥的效果，他们必须用同一个对象。
```

### 5.线程范围类的数据共享（Map）
```
将数据存入Map中，线程名作为key值
```

### 6.线程范围类的数据共享(ThreadLocal)--底层实现是Map
```
一个变量
多个变量封装成一个实例
多个变量封装成一个实例（单例模式实现）
```

### 7.多个线程之间共享数据
```
Note:
一、每个线程执行的代码相同
如果每个线程执行的代码相同，可以使用同一个Runnable对象，
此Runnable对象存在共享数据,
如: 卖票程序可以这么做，因为都是执行减少的过程


二、每个线程执行的代码不相同
方法1：将需要共享的数据封装成一个对象，将该对象传给执行不同代码的Runnable对象。
方法2：将这些执行不同代码的Runnable对象作为内部类。
如：有4个线程，其中有2个线程对每次对j+1，有2个线程对每次对j-1。
加减操作无顺序。
```

### 8.原子性操作类
```
java.util.concurrent.atomic包--对类中的基本数据进行操作
AtomicBoolean、AtomicInteger、AtomicIntegerArray、
AtomicLong、...
```

### 9.线程池
```
创建固定大小的线程池
创建缓存线程池
创建单一线程池

关闭线程
shutdown和shutdownNow

定时器
```

### 10.Callable和Future

### 11.Java5的线程锁
```
多个线程要执行的代码片段要实现同步互斥，他们必须用同一个Lock对象。
锁是上在代表要操作的资源的内部方法中，而不是线程代码中。
```

### 12.Java5的读写锁
```
读写锁：分为读锁和写锁，多个读锁不互斥，读锁和写锁互斥，写锁和写锁互斥，
这是由Jvm控制的，只需上好相应的锁即可。读的时候上读锁，写的时候上写锁。
```

### 13.Java的条件阻塞
```
同步互斥
可阻塞队列
三个线程同步互斥
```

### 14.信号灯(Semaphore)
```
可以维护当前访问自身的线程个数，并提供同步机制。使用Semaphore可以控制同时访问资源的线程个数。
可以通过构造方法设置参数控制谁先进。
单个信号灯可以实现互斥锁的功能。并且可以是一个线程获得了锁，再由另一个线程释放锁，这可应用与死锁恢复的一些场景。
```

### 15.Java5的CyclicBarrier同步工具
```
CyclicBarrier表示大家彼此等待，大家集合好后才开始出发，分散活动后又在指定地点集合碰面。
```

### 16.java5的CountDownLatch同步工具
```
CountDownLatch犹如倒计时计数器，调用CountDownLatch对象的countDown方法将计数器减1，当计数器达到0时，
则所有等待着开始执行。
```

### 17.java5的Exchanger同步工具
```
Exchanger两个线程的数据交换
```

### 18.java5阻塞队列的应用
```
队列包含固定长度的队列和不固定长度的队列。
ArrayBlockingQueue

BlockingQueueMain
BlockingQueueCommunication
```

### 19.java5同步集合类的应用
```
ArrayBlockingQueue<E> 一个由数组支持的有界阻塞队列。
ConcurrentHashMap<K,V> 支持获取的完全并发和更新的所期望可调整并发的哈希表。
ConcurrentLinkedQueue<E> 一个基于链接节点的无界线程安全队列。
ConcurrentSkipListMap<K,V> 可缩放的并发 ConcurrentNavigableMap 实现。
ConcurrentSkipListSet<E> 一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。
CopyOnWriteArrayList<E> ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。
CopyOnWriteArraySet<E> 对其所有操作使用内部 CopyOnWriteArrayList 的 Set。
```

### 20.传智播客_张孝祥_空中网挑选实习生的面试题1
```
现有的程序代码模拟产生了16个日志对象，并且需要运行16秒，才能打印完这些日志，
请在程序中增加4个线程去调用parseLog()方法来分别打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。
```


### 21.传智播客_张孝祥_空中网挑选实习生的面试题2
```
现成程序中的Test类中的代码不断产生数据，然后交给TestDo.doSome()方法去处理，
就好像生产者在不断地产生数据，消费者在不断地消费数据。
请将程序改造成有10个线程来消费生产者产生的数据，只有上一个消费者消费完之后，下一个消费者才能消费数据，
下一个消费者是谁都可以，但是要保证这些消费者线程拿到的数据是有顺序的。
```

### 20.传智播客_张孝祥_空中网挑选实习生的面试题3
```
现有程序同时启动了4个线程去调用TestDo.doSome(key,value)方法，由于Test.doSome(key,value)
方法内的代码是先暂停1秒，然后再输出以秒为单位的当前时间值，所以，会打印出4个相同的时间值，如下
所示：
4:4:1238199615
1:1:1238199615
3:3:1238199615
1:2:1238199615
请修改代码，如果有几个线程调用TestDo.doSome(key,value)方法时，
传递进去的key相等（equals比较为true），
则这几个线程应互斥排队输出结果，即当有两个线程的key都是“1”时，
他们中的一个要比另外其他线程晚一秒输出结果，如下所示：
4:4:1238199615
1:1:1238199615
3:3:1238199615
1:2:1238199616
总之，当每个线程中指定的key相等时，这些相等的key的线程应每隔一秒依次输出时间值（要用互斥），
如果key不同，则并行执行（相互之间不互斥）。
```












