### 1.传统创建线程的两种方式
```
继承Thread类+重写run()方法
实现Runnable接口+重写run方法
```


### 2.传统的定时器
```
继承TimerTask类+重写run方法
```

### 3.传统的线程同步
```
多个线程对同一个对象进行修改
```

### 4.传统的线程同步
```
两个线程执行的代码片段要实现同步互斥的效果，他们必须用同一个对象。
```

### 5.线程范围类的数据共享（Map）
```
将数据存入Map中，线程名作为key值
```

### 6.线程范围类的数据共享(ThreadLocal)--底层实现是Map
```
一个变量
多个变量封装成一个实例
多个变量封装成一个实例（单例模式实现）
```

### 7.多个线程之间共享数据
```
Note:
一、每个线程执行的代码相同
如果每个线程执行的代码相同，可以使用同一个Runnable对象，
此Runnable对象存在共享数据,
如: 卖票程序可以这么做，因为都是执行减少的过程


二、每个线程执行的代码不相同
方法1：将需要共享的数据封装成一个对象，将该对象传给执行不同代码的Runnable对象。
方法2：将这些执行不同代码的Runnable对象作为内部类。
如：有4个线程，其中有2个线程对每次对j+1，有2个线程对每次对j-1。
加减操作无顺序。
```

### 8.原子性操作类
```
java.util.concurrent.atomic包--对类中的基本数据进行操作
AtomicBoolean、AtomicInteger、AtomicIntegerArray、
AtomicLong、...
```

### 9.线程池
```
创建固定大小的线程池
创建缓存线程池
创建单一线程池

关闭线程
shutdown和shutdownNow

定时器
```

### 10.Callable和Future

### 11.Java5的线程锁
```
多个线程要执行的代码片段要实现同步互斥，他们必须用同一个Lock对象。
锁是上在代表要操作的资源的内部方法中，而不是线程代码中。
```

### 12.Java5的读写锁
```
读写锁：分为读锁和写锁，多个读锁不互斥，读锁和写锁互斥，写锁和写锁互斥，
这是由Jvm控制的，只需上好相应的锁即可。读的时候上读锁，写的时候上写锁。
```

### 13.Java的条件阻塞
```
同步互斥
可阻塞队列
三个线程同步互斥
```

### 14.信号灯(Semaphore)
```
可以维护当前访问自身的线程个数，并提供同步机制。使用Semaphore可以控制同时访问资源的线程个数。
可以通过构造方法设置参数控制谁先进。
单个信号灯可以实现互斥锁的功能。并且可以是一个线程获得了锁，再由另一个线程释放锁，这可应用与死锁恢复的一些场景。
```

### 15.Java5的CyclicBarrier同步工具
```
CyclicBarrier表示大家彼此等待，大家集合好后才开始出发，分散活动后又在指定地点集合碰面。
```

### 16.java5的CountDownLatch同步工具
```
CountDownLatch犹如倒计时计数器，调用CountDownLatch对象的countDown方法将计数器减1，当计数器达到0时，
则所有等待着开始执行。
```

### 17.java5的Exchanger同步工具
```
Exchanger两个线程的数据交换
```

### 18.java5阻塞队列的应用
```

```

### 19.java5同步集合类的应用
```

```

### 20.传智播客_张孝祥_空中网挑选实习生的面试题1
```

```


### 21.传智播客_张孝祥_空中网挑选实习生的面试题2
```

```

### 20.传智播客_张孝祥_空中网挑选实习生的面试题3
```

```